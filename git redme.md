# Рекурсия в JS
>Рекурсия — это процесс вызова функцией самой себя. Функция, которая в своем теле вызывает сама себя, называется рекурсивной функцией.

### Синтаксис
```js
function recurse() {
    // код функции
    recurse(); // функция вызывает сама себя
    // код функции 
}

console.log(recurse());
```
>Как это работает:
![alt text](<pasted image 0.png>)

_______________
_______________
_______________
Внутри рекурсивной функции обязательно должно находится условие выхода из рекурсии. Иначе функция будет вызывать саму себя бесконечно.

Как только условие выхода выполняется, функция перестает вызывать себя. 

Чтобы предотвратить бесконечную рекурсию, можно использовать оператор if...else (или аналогичный подход), в котором одна ветвь выполняет рекурсивный вызов, а другая — нет.
_______
_______
#### Основные концепции:
* Базовый случай (Base Case): Это условие, которое определяет, когда рекурсивная функция должна остановиться. Без базового случая рекурсия будет продолжаться бесконечно.
* Рекурсивный случай (Recursive Case): Это условие, при котором функция вызывает саму себя. Он определяет, как задача разбивается на более мелкие подзадачи.
  
_______
_______
### Примеры решение задач:
Вычисление факториала:
```js
function factorial(n) {
    if (n === 0 || n === 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
```

Вычисление чисел Фибоначчи:
```js
function fibonacci(n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```
___________
___________
___________
# Сlosure в JS
Замыкание (closure) - это особенность языка программирования, позволяющая функции запоминать окружение, в котором они были созданы, даже после того, как это окружение вышло из области видимости. Это означает, что функция имеет доступ к переменным из внешней области видимости, где она была объявлена, даже после того, как эти переменные уже не существуют.
### Например:
```js
function outer() {
    let outerVariable = 'I am from outer function';

    function inner() {
        console.log(outerVariable); 
    }

    return inner;
}

const closureExample = outer();
closureExample(); 
```
Здесь innerFunction является замыканием, потому что она имеет доступ к переменной outerVariable, которая была объявлена во внешней функции outerFunction. Даже после завершения выполнения outerFunction, innerFunction все еще имеет доступ к outerVariable, потому что она "замыкает" или сохраняет ссылку на эту переменную.<br>
* * 
  Замыкания часто используются в JavaScript для создания приватных переменных и методов в объектах, реализации функций обратного вызова (callback) и мемоизации (хранения результатов выполнения функций для повторного использования).  
___________
__________